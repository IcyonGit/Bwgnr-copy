<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Computer Science</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="http://bwagner.org/menu/uil/css/menu.css">
<link rel="stylesheet" href="http://bwagner.org/menu/uil/css/computerscience.css">
</head>
<body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table border="0" align="left" cellpadding="10" cellspacing ="0">
  <tr>
    <th width="99%" class="main"> 7.1 Set</th>
  </tr>
  <tr> 
    <td class="main" colspan="2"> <p><strong>Unordered Collection: </strong>Set</p>
      <p><strong>Interfaces: </strong>Set 
      <p><strong>Implementing Classes: </strong>HashSet, TreeSet</p>
      <hr> <h2>Unordered Collections</h2>
      <p>A linear collection is an ordered collection. That is, each item in an 
        linear collection has a position at which the client can locate it. In 
        this unit, we look at<strong> unordered collections</strong>. From the 
        client's perspective, the items in an unordered collection are in no particular 
        order. Thus, none of the operations on an unordered collection are position-based. 
        Clients can insert, retrieve, or remove objects from unordered collections, 
        but they cannot access the <em>nth</em> item, the next item, or the previous 
        item. In this unit we look at two types of unordered collections: <strong>set</strong> 
        and <strong>map</strong>.</p>
      <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unordered 
        Collection</strong></p>
      <p><img src="http://bwagner.org/menu/uil/Lessons/Unordered%20Collections/img/unorderedCollection.gif" width="400" height="250"></p>
      <h2>Set</h2>
      <p>A <strong>set</strong> is a collection that cannot contain duplicate 
        elements. This interface models the concept of a set your are familiar 
        with from mathematics. Some of the operations that you can be performed 
        on sets in mathematics include adding an item to a set, removing an item 
        from a set, returning the union, intersection, or difference of two sets, 
        and testing for the empty set. Outside the realm of mathematics sets can 
        be used to represent such things as the cards comprising a poker hand, 
        the courses making up a student's schedule, or the processes running on 
        a machine.</p>
      <p>The JCF provides an interface to represent some of the functionality 
        of a set. The <em>Set</em> interface contains methods inherited from the 
        <em>Collection</em> interface and adds the restriction that duplicate 
        elements are prohibited.</p>
      <p>A set allows you to</p>
      <ul>
        <li>Insert a nonduplicate element into the set.</li>
        <li>Remove an element from the set.</li>
        <li>Test if a given element is in the set.</li>
        <li>Iterate over the elements using Iterator.</li>
      </ul>
      <h3>interface java.util.Set&lt;E&gt; (AP subset)</h3>
      <table class="notes" width="60%" border="1">
        <tr bgcolor="#FFFFE8" class="notes"> 
          <td width="40%"><font color="#000000" face="Courier New, Courier, mono">int 
            <strong>size</strong>()</font></td>
          <td width="60%">returns number of items in set</td>
        </tr>
        <tr bgcolor="#FFFFE8" class="notes"> 
          <td><font color="#000000" face="Courier New, Courier, mono">boolean 
            <strong>contains</strong>(Object obj)</font></td>
          <td><p>returns true if obj is in the set;<br>
              otherwise, returns false</p></td>
        </tr>
        <tr bgcolor="#FFFFE8" class="notes"> 
          <td><font color="#000000" face="Courier New, Courier, mono">boolean 
            <strong>add</strong>(Object obj)</font></td>
          <td><font color="#000000">if obj is not present in this set, adds obj 
            and returns true;</font><br>
            otherwise, returns false</td>
        </tr>
        <tr bgcolor="#FFFFE8" class="notes"> 
          <td><font color="#000000" face="Courier New, Courier, mono">boolean 
            <strong>remove</strong>(Object obj)</font></td>
          <td><font color="#000000">if obj is present in this set, removes obj 
            and returns true;</font><br>
            otherwise, returns false</td>
        </tr>
        <tr bgcolor="#FFFFE8" class="notes"> 
          <td><font color="#000000" face="Courier New, Courier, mono">Iterator 
            &lt;E&gt; <strong>iterator</strong>()</font></td>
          <td>returns an iterator on the set</td>
        </tr>
      </table>
      <br>
      <h2>Implementing Classes</h2>
      <p>The JCF provides two <em>Set</em> implementations called <strong>HashSet</strong> 
        and <strong>TreeSet</strong>. The names are derived from the techniques 
        used to store and access a set's items. A <em>HashSet</em> stores its 
        elements in a hash table and the <em>TreeSet</em> stores its elements 
        in a balanced binary search tree. We will look more closely at the implementation 
        of these two data structures in a future unit. </p>
      <p>Determining which of these two classes to use is generally straightforward. 
        <em>HashSet</em> is much faster than <em>TreeSet</em> (constant-time O(1) 
        versus log-time O(log) for most operations) but offers no ordering guarantees. 
        If value-ordered iteration is required, use <em>TreeSet</em>; otherwise, 
        use <em>HashSet</em>. It's a fair bet that you'll end up using <em>HashSet</em> 
        most of the time. </p>
      <h3>HashSet Class (class java.util.HashSet&lt;E&gt; implements java.util.Set&lt;E&gt;)</h3>
      <p>The <em>HashSet</em> class stores items in no particular order. The methods 
        of <em>HashSet</em> in the AP Java subset are the same methods as those 
        given for the <em>Set</em> interface: <strong>add</strong>, <strong>contains</strong>, 
        <strong>remove, size</strong>, and <strong>iterator</strong>.</p>
      <p><strong>Iterator</strong></p>
      <p>An iterator for a <em>HashSet</em> returns the elements in no particular 
        order and does not guarantee that the order will stay the same over time.</p>
      <h3><strong>HashSet Examples</strong></h3>
      <p><strong>constructor</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();<br></pre></td>
        </tr>
      </table>
      <p><strong>add Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>set.add(&quot;dog&quot;);
set.add(&quot;cat&quot;);
set.add(&quot;bird&quot;);<br></pre></td>
        </tr>
      </table>
      <p><strong>remove Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>set.remove(&quot;bird&quot;);<br></pre></td>
        </tr>
      </table>
      <p><strong>contains Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre> if(set.contains(&quot;cat&quot;))<br> {<br>	 System.out.println(&quot;Set contains: Cat&quot;);<br> }<br></pre></td>
        </tr>
      </table>
      <p><strong>size Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>System.out.println(&quot;Size = &quot; + set.size());<br></pre></td>
        </tr>
      </table>
      <p><strong>Traverse - iterator</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>Iterator it = set.iterator();<br>while(it.hasNext())<br>{<br>   System.out.println(it.next());<br>}<br></pre></td>
        </tr>
      </table>
      <br>
      <table width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td bgcolor="#000000"> <p><font color="#FFFFFF" face="Courier New, Courier, mono">dog 
              <br>
              cat<br>
              bird </font></p>
            </td>
        </tr>
      </table>
      * no particular order
      <p><strong>Traverse - enhanced for</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>for(String str : set)<br>{<br>   System.out.println(str);
}<br></pre></td>
        </tr>
      </table>
      <br>
      <table width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td bgcolor="#000000"> <p><font color="#FFFFFF" face="Courier New, Courier, mono">dog<br>
              cat</font><br>
              <font color="#FFFFFF" face="Courier New, Courier, mono">bird </font></p>
            </td>
        </tr>
      </table>
      * no particular order
      <h3>TreeSet class (class java.util.TreeSet&lt;E&gt; implements java.util.Set&lt;E&gt;)</h3>
      <p>Sets are unordered collections; however, there is sufficient need for 
        a sorted version that Java includes the interface <em>SortedSet</em> and 
        the implementation of the<em> TreeSet</em> class. The <em>TreeSet</em> 
        class guarantees that the sorted set will be in ascending order, as determined 
        by the <em>compareTo</em> method of the elements within the set. This 
        means that the items of a <em>TreeSet</em> are <em>Comparable</em>. As 
        with <em>HashSet</em>, the <em>TreeSet</em> methods in the AP Java subset 
        are those specified for the <em>Set</em> interface: <strong>add</strong>, 
        <strong>contains</strong>, <strong>remove</strong>, <strong>size</strong>, 
        and <strong>iterator</strong>.</p>
      <p><strong>Iterator</strong></p>
      <p>The iterator for a <em>TreeSet</em> always returns the elements in ascending 
        order.</p>
      <p><strong>TreeSet Examples</strong></p>
      <p><strong>constructor</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();<br></pre></td>
        </tr>
      </table>
      <p><strong>add Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>set.add(&quot;dog&quot;);
set.add(&quot;cat&quot;);
set.add(&quot;bird&quot;);<br></pre></td>
        </tr>
      </table>
      <p><strong>remove Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>set.remove(&quot;bird&quot;);<br></pre></td>
        </tr>
      </table>
      <p><strong>contains Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre> if(set.contains(&quot;cat&quot;))<br> {<br>	 System.out.println(&quot;Set contains: Cat&quot;);<br> }<br></pre></td>
        </tr>
      </table>
      <p><strong>size Method</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>System.out.println(&quot;Size = &quot; + set.size());<br></pre></td>
        </tr>
      </table>
      <p><strong>Traverse - iterator</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>Iterator it = set.iterator();<br>while(it.hasNext())<br>{<br>   System.out.println(it.next());<br>}<br></pre></td>
        </tr>
      </table>
      <br>
      <table width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td bgcolor="#000000"> <p><font color="#FFFFFF" face="Courier New, Courier, mono">bird<br>
              cat<br>
              dog </font></p>
            </td>
        </tr>
      </table> 
*ascending order
      <p><strong>Traverse - enhanced for</strong></p>
      <table class="code"width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td class="code"><pre>for(String str : set)<br>{<br>   System.out.println(str);
}<br></pre></td>
        </tr>
      </table>
      <br>
      <table width="67%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td bgcolor="#000000"> <p><font color="#FFFFFF" face="Courier New, Courier, mono">bird<br>
              cat<br>
              dog </font></p></td>
        </tr>
      </table> 
      * ascending order 
      <h2>&nbsp;</h2>
      <h3>&nbsp;</h3>
      <h3>&nbsp;</h3>
      <h3>&nbsp;</h3>
      <p>&nbsp;</p>
      <p>&nbsp;</p></td>
  </tr>
</table>