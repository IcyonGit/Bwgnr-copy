What is output by the code
to the right?
$
PriorityQueue<Integer> pq;
pq = new PriorityQueue<Integer>();

pq.add(9);
pq.add(4);
pq.add(9);
pq.add(1);

while( !pq.isEmpty() )
  System.out.print( pq.remove() );
$
9491
$
1949
$
1499
$
149
$
941
$
C
$
What is output by the code
to the right?
$
PriorityQueue<Integer> pq;
pq = new PriorityQueue<Integer>();
int [] toAdd = {12, 5, 7, 5, 8};

for(int i : toAdd)
  pq.add(i);

pq.remove();
System.out.println( pq.peek() );
$
12
$
5
$
7
$
8
$
null
$
B
$
How does the priority queue
to the right behave like?
$
PriorityQueue<Integer> pq;
pq = new PriorityQueue<Integer>();

Integer[] x = {17, 38, 2, 22, 30, 10};

for(Integer i : x)
  pq.add(i); 

System.out.println(pq);
$
binary search tree
$
min heap tree
$
max heap tree
$
a queue
$
a linked list
$
B
$
What replaces <*1> in the code
to the right to decrement
the value stored inside the
variable p?
$
public class Structure{
  private ArrayList<Integer> ks;
  private ArrayList<Object> vs;

  public Structure(){
    ks = new ArrayList<Integer>();
    vs = new ArrayList<Object>();
  }

  public void add(int k, Object v){
    int p = ks.size();
    while(p > 0 && k <= ks.get(p - 1) )
    <*1>;
    ks.add(p, k);
    vs.add(p, v);
  }

  public boolean isEmpty(){
    return ks.size() == 0;
  }

  public Object access(){
    return vs.get( ks.size() - 1 );
  }

  public Object remove(){
    ks.remove(ks.size() - 1);
    return vs.remove( vs.size() - 1 );
  }
}

//////////////////////////////////////////
// client code
Structure str = new Structure();
str.add(10, "GG");
str.add(12, "MM");
str.add(12, "GG");
str.add(5, "UU");
System.out.print( str.access() );
$
p -= 1
$
p *= -1
$
p >> 2
$
p << 1
$
p++
$
A
$
Assume <*1> is filled 
in correctly.

What is output by the client
code to the right?
$
public class Structure{
  private ArrayList<Integer> ks;
  private ArrayList<Object> vs;

  public Structure(){
    ks = new ArrayList<Integer>();
    vs = new ArrayList<Object>();
  }

  public void add(int k, Object v){
    int p = ks.size();
    while(p > 0 && k <= ks.get(p - 1) )
    <*1>;
    ks.add(p, k);
    vs.add(p, v);
  }

  public boolean isEmpty(){
    return ks.size() == 0;
  }

  public Object access(){
    return vs.get( ks.size() - 1 );
  }

  public Object remove(){
    ks.remove(ks.size() - 1);
    return vs.remove( vs.size() - 1 );
  }
}

//////////////////////////////////////////
// client code
Structure str = new Structure();
str.add(10, "GG");
str.add(12, "MM");
str.add(12, "GG");
str.add(5, "UU");
System.out.print( str.access() );
$
MM
$
UU GG MM GG
$
GG
$
12
$
UU
$
A
$
What type of data structure
does the Structure class
implement?
$
public class Structure{
  private ArrayList<Integer> ks;
  private ArrayList<Object> vs;

  public Structure(){
    ks = new ArrayList<Integer>();
    vs = new ArrayList<Object>();
  }

  public void add(int k, Object v){
    int p = ks.size();
    while(p > 0 && k <= ks.get(p - 1) )
    <*1>;
    ks.add(p, k);
    vs.add(p, v);
  }

  public boolean isEmpty(){
    return ks.size() == 0;
  }

  public Object access(){
    return vs.get( ks.size() - 1 );
  }

  public Object remove(){
    ks.remove(ks.size() - 1);
    return vs.remove( vs.size() - 1 );
  }
}

//////////////////////////////////////////
// client code
Structure str = new Structure();
str.add(10, "GG");
str.add(12, "MM");
str.add(12, "GG");
str.add(5, "UU");
System.out.print( str.access() );
$
a stack
$
a heap
$
a list
$
a binary search tree
$
a priority queue
$
E